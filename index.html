<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Pipresents-next-digital-photo-frame by najoshi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Pipresents-next-digital-photo-frame</h1>
      <h2 class="project-tagline"> Modifying Pi Presents-next for use in a digital photo frame project</h2>
    </section>

    <section class="main-content">

<h4>I wanted to make a digital photo frame that:</h4>

<ul>
<li>Would show both pictures and video with sound</li>
<li>Would have high storage capacity</li>
<li>Would shuffle the pictures/videos so they weren't in order</li>
<li>Would have buttons to pause and go forwards/backwards through the slideshow</li>
<li>Would have the capability of annotating the pictures and video with text</li>
<li>Would have a motion sensor</li>
<li>Would be large in size, i.e. a large monitor</li>
<li>Would all fit in one package to mount on the wall, i.e. storage, the Pi, buttons, the monitor, etc.</li>
<li>Would be able to handle tens of thousands of pictures and video</li>
<li>Would not need soldering</li>
</ul>


<h4>Video of media frame in action:</h4>

 <video width="640" height="480" controls>
  <source src="media/MVI_0406.mp4" type="video/mp4">
Your browser does not support the video tag.
</video> 


<h1>INSTRUCTIONS</h1>

<h3>NOTE: Some Linux and possibly programming experience is required.</h3>

<h3>Things you'll need:</h3>
<ul>
<li><a href="https://www.adafruit.com/products/3055">Raspberry Pi</a> (I originally did this project with a Pi 2, but it should work just the same with a Pi 3.)</li>
<li><a href="https://www.adafruit.com/products/2767">SD card with Raspbian</a></li>
<li><a href="https://www.adafruit.com/products/608">HDMI cable</a></li>
<li><a href="https://www.adafruit.com/products/189">PIR motion sensor</a></li>
<li><a href="https://www.adafruit.com/products/1950">Female-to-Female Jumper Wires</a></li>
<li><a href="https://www.adafruit.com/products/1952">Female-to-Male Jumper Wires</a></li>
<li><a href="https://www.adafruit.com/products/64">Half size breadboard</a></li>
<li><a href="https://www.sparkfun.com/products/9190">3 pushbutton switches</a></li>
<li><a href="https://www.adafruit.com/product/1995">5V 2.4A MicroUSB power supply</a></li>
<li><a href="https://www.adafruit.com/products/1998">Raspberry Pi enclosure</a></li>
<li><a href="http://www.amazon.com/dp/B00EZSUVHK/ref=pe_385040_121528360_TE_dp_1">24" HD Viewsonic LCD monitor with sound and VESA compliant</a></li>
<li><a href="http://www.amazon.com/Universal-LCD-F-1-Insignia-Panasonic-Magnavox/dp/B00P32KQXG/ref=sr_1_4">Universal Flat Wall Mount for VESA monitor</a></li>
<li><a href="http://www.amazon.com/VELCRO-Sticky-Back-Strips-Black/dp/B000TGSPV6/ref=sr_1_2">Velcro strips</a></li>
<li><a href="http://www.amazon.com/Seagate-Portable-External-Storage-STDR1000100/dp/B00H4XH5FY/ref=sr_1_1">External Hard Drive</a></li>
<li><a href="https://www.sparkfun.com/products/8837">Rocker switch</a></li>
<li><a href="http://tinkersphere.com/buttons-switches/289-toggle-slide-switch-breadboard-perfboard-compatible-spdt.html">Toggle slide switch</a></li>
<li>Hot Glue Gun</li>
<li>Flexible semi-rigid rubber-coated wire (for mounting PIR sensor)</li>
<li>Possibly a mircoUSB extension cord if the power supply won't reach</li>
</ul>

<h2><u>Step 1</u></h2>

Find a spot where your digital media frame will eventually go. You'll want a space that is centrally located which gets high traffic and visibility and where you can mount it on a stud or strut (basically into wood, not drywall). And, of course, it will need access to electricity.

<h2><u>Step 2</u></h2>

Since the Pi enclosure doesn't quite fit with our jumper wires and we don't want to solder, we need to make a little room in the enclosure. Use a hacksaw to cut a small section out of the top to allow for our wires to stick out. Fit your Pi into the enclosure and insert your Rasbpian microSD card into the Pi's card slot.

<img src="media/IMG_0404.resized.JPG" vspace=20>

<h2><u>Step 3</u></h2>

Now, you should test your Pi. Connect it to the monitor using the HDMI cable and connect it to power using the microUSB power supply. There is no "on/off" switch on the Pi so it will start as soon as it is connected to power. You'll also want to connect a keyboard and a mouse to the Pi initially for testing and setup. Follow some tutorial (such as <a href="https://www.howtoforge.com/tutorial/howto-install-raspbian-on-raspberry-pi/">this</a>) to get the Pi up and running. Make sure your filesystem is expanded, you choose the graphical desktop option for boot, and you update the firmware.

<h2><u>Step 4</u></h2>

Next, follow the installation instructions for the <a href="https://github.com/KenT2/pipresents-next">original pipresents-next</a> and test it out on one of their examples just to make sure it works.

<h2><u>Step 5</u></h2>

Download my fork of pipresents-next <a href="https://github.com/najoshi/pipresents-next-digital-photo-frame">here.</a> I've only changed six of the python files (pp_gpio.py, pp_imageplayer.py, pp_medialist.py, pp_mediashow.py, pp_omxdriver.py, pp_videoplayer.py) and I've commented them with the comment string "NIK" around my changes. Of course, I also changed the README.md and the gpio.cfg file. It probably will not work immediately because none of the inputs are connected. So the next thing you need to do is start connecting the gpio inputs.

<h2><u>Step 6</u></h2>

Now you will connect up the half-size breadboard with our buttons for next, previous, and pause, and the sensor on/off switch. You will be using female-to-male jumper wires. First, insert the pushbuttons so that they straddle the central groove and are spaced equally apart. Make sure the button prongs are inserted fully into the breadboard. Insert a jumper wire for each button into the row of the left prong, where the row is perpendicular to the middle groove. Each row is electrically connected, so it doesn't matter which of the 5 sockets (not including the +/- columns) you put it in, as long as it is in the same row on the same side of the groove. Leave the female ends dangling for now, we will connect them later to the Pi.

<img src="media/IMG_0397.resized.JPG" vspace=20>
<img src="media/IMG_0397_arrow1.resized.JPG" vspace=20>

Next, insert two more jumper wires into the end of each of the "+" and "-" columns. These will supply our ground and power for our buttons and switches. In order to connect the buttons to the ground column, you will need to create little wire connectors. In order to do this, take a new wire and cut three small pieces out of it. For each piece, slice off the rubber coating at the ends (without cutting the copper wire underneath). Then twist the bare wire ends to make them easier to insert.

<img src="media/IMG_0408.resized.JPG" vspace=20>
<img src="media/IMG_0409.resized.JPG" vspace=20>
<img src="media/IMG_0411.resized.JPG" vspace=20>

Insert the wires so they connect the other prong of the buttons to the ground (i.e. "-") column. Finally, insert the switch into the board on one side of the buttons. Connect the middle prong of the switch to power using another wire connector and connect the right prong to another female-to-male wire. Then I covered the wire connections in tape so that they would stay secure... hacky, I know.

<img src="media/IMG_0397_arrow2.resized.JPG" vspace=20>


<h2><u>Step 7</u></h2>

Now, we will connect the female ends of the wires to the Pi. Here is a simplified pin layout of the Pi:

<img src="media/Raspberry-Pi-GPIO-Layout-simple.jpg" vspace=20>

And here are the wires on the breadboard with the corresponding pin numbers of where they connect to:

<img src="media/IMG_0397_pins.resized.JPG" vspace=20>

And, finally, here is a diagram of the Pi pins with the numbers the wires connect to:

<img src="media/gpio-pins-pi2-arrow1.resized.jpg" vspace=20>

So, simply connect the dangling female ends of the wires from the breadboard to the corresponding pin numbers on the Pi. Finally, at this point, you may want to use velcro to attach the Pi enclosure and the breadboard to the monitor.

<img src="media/IMG_0405.resized.JPG" vspace=20>

Below is what the final product will look like, but for now attach the enclosure and board to the places where you see them in the picture.

<img src="media/IMG_0399.resized.JPG" vspace=20>


<h2><u>Step 8</u></h2>

In this step, we will connect the PIR sensor to the Pi, test out the best settings for it, and mount it on the monitor. First, thread the semi-rigid rubber-coated wire through the holes on the sides of the PIR. This will create a mounting surface. If you have a better way of mounting the sensor without causing electrical interference, then do it, but this is the easiest way I could come up with. Use strong tape to place the sensor on the back of the monitor next to the "Viewsonic" logo (later we will hot glue gun it in place):

<img src="media/IMG_0394.resized.JPG" vspace=20>

Using female-to-female wires, connect the PIR sensor pins to pins 2, 11, and 6 on the Pi (as shown below):

<img src="media/IMG_0394_arrow1.resized.JPG" vspace=20>
<img src="media/gpio-pins-pi2-arrow2.resized.jpg" vspace=20>

Now, let's test the PIR sensor. You may want to mount the monitor where it is supposed to go, or at least be able to place it there temporarily. You may also want to enable ssh login into the Pi so you don't need a keyboard and mouse connected directly to it. In the digital photo frame repo, there is a "scripts" directory. In that directory, there is a script named "pir.py". Run that script on the command-line on the Pi using sudo (i.e. "sudo pir.py"). This script just runs in a loop and polls the PIR to see if there is signal (i.e. movement). After 30 seconds of no movement, it will put the monitor on standby. Then when there is movement, it will turn the monitor on again. Use this to test the motion sensor and its placement on the monitor. There are also two analog dials on the PIR itself that control the delay of the signal firing (labelled "time") and the sensitivity of the sensor (labelled "sensitive"). You'll want to put the delay at minimum and then play with the sensitivity to get the right distance at which you want motion to trigger the sensor. Finally, when you have figured out the best placement and settings for the PIR, use your hot glue gun on the rubber-coated wire supports to glue it into place.


<h2><u>Step 9</u></h2>

In this step, we will add an off switch, tape up the Pi, and add the hard drive. The off switch is optional, as the script that contols the switch is totally separate from pipresents. I just wanted a way to easily switch off the Pi by using a switch to run the "shutdown" command. Unfortuately, it only works as on "off" switch, NOT an "on" switch. After you turn off the Pi, in order to turn it back on you have to power cycle it. So it is pretty janky, and thus not necessary. However, if you do want to add the switch, you will use two female-to-female wires and connect them to the switch by jamming the ends into the prongs. The prongs don't exactly fit the connectors, so you will have to force them. Take a look at the pictures below to see how to connect them:

<img src="media/IMG_0399_arrow1.resized.JPG" vspace=20>
<img src="media/gpio-pins-pi2-arrow3.resized.jpg" vspace=20>

Finally, as shown above, tape up the wires into the Pi so that the hole is covered and the wires are secure. Use hot glue to glue the switch to the monitor. Use velcro to attach the hard drive to the monitor and then connect it to the Pi. Finally, you might need to use some velcro/hot glue combination to keep the HDMI cable from dangling below the monitor.


<h2><u>Step 10</u></h2>

Now, let's test pipresents with our enhancements. First, make sure you go to the <a href="https://github.com/KenT2/pipresents-next">README</a> on the pipresents page and follow the instructions on installing required applications and installing pexpect. You should read the manual (which is in the repo) and use the profile editor to create a new profile and a new mediashow, but remember to do it in the "pipresents-next-digital-photo-frame" directory. I called mine "digital_media_frame". Keep in mind that pipresents-next cannot handle photo files much larger than 1Mb and does not use the EXIF data in a photo file. So any photos you put into the mediashow will need to be rotated according to the EXIF data and then resized to fit in the monitor. I use "jhead -autorot" and "convert -resize 1920x1080" to do this. You should also put a video in the mediashow to test it out. Remember to run it using "sudo" and with the "--gpio" option. Later, you will use scripts and programs I have written to create the json file for the media show, but for now, test it using the editor. Make sure to test all the buttons and the PIR motion sensor.


<h2><u>Step 11</u></h2>

Now, we will make the whole thing production ready. We need to make it so that pipresents starts up automatically and takes up the entire screen, and we need to make some other adjustments for a smooth operation. First, let's change the /boot/config.txt file (using sudo). Uncomment and add/change these lines:
<pre><code>
disable_overscan=1
framebuffer_width=1920
framebuffer_height=1080
max_usb_current=1
gpu_mem=128
</code></pre>

You will need to reboot the Pi for the changes to take effect. Next, follow the directions in the manual in section 5.4.7.2 to make pipresents work full screen. Then follow the directions in section 9.6 to start pipresents automatically. Instead of putting the pipresents line directly in the autostart file, you should create another file called "start_pipresents.sh" in that directory and put these lines in that file:
<pre><code>
#!/bin/bash

sleep 10
sudo python /home/pi/pipresents-next-digital-photo-frame/pipresents.py --gpio -f -b -o /home/pi/pipresents-next-digital-photo-frame -p digital_media_frame
</code></pre>

Then put a call to "start_pipresents.sh" in autostart. This is for our external hard drive... it needs a few extra seconds to get mounted so we sleep 10 seconds before starting pipresents. Now, we will transition all of the profile data to the external drive. What you need to do is find out where your external hard drive is being mounted to and make your media directory a link to a media directory on the hard drive. So, for example, I created a directory called "media" on my external drive and then inside the pipresents-next-digital-photo-frame/pp_home directory I have a link to "/media/Seagate Expansion Drive/media/". This is where all of the pictures and video will go. Then I put my media.json file in the media direcotry and in the pipresents-next/pp_home/pp_profiles/digital_media_frame directory, I create a link to "/media/Seagate Expansion Drive/media/media.json". Also, in the pp_showlist.json file, you may want to change the "duration" setting to however many seconds you want each picture to be shown on the screen.<br/>

Finally, if you added the off switch to your frame, edit /etc/rc.local (using sudo), and put a call to the sd_check.py script located in the scripts directory. So it would look something like this:
<pre><code>
sudo /home/pi/pipresents-next-digital-photo-frame/scripts/sd_check.py &
exit 0
</code></pre>

You'll need to reboot for the changes to take effect. You may want to mute the sound of the monitor so that you don't have sounds coming from video unless you want it... and then you can unmute for that video and mute again when you are done.a Your photo frame should now work full screen and automatically.

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/najoshi/pipresents-next-digital-photo-frame">Pipresents-next-digital-photo-frame</a> is maintained by <a href="https://github.com/najoshi">najoshi</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
